# Spring

## Spring解析

1. 从此方法开始debug

   ```java
   new AnnotationConfigApplicationContext(MainConfigAOp.class);
   ```

2. 进入类AnnotationConfigApplicationContext，执行构造方法

   * 该类继承于BeanFactory

   ```java
   //根据参数类型可以知道，其实可以传入多个annotatedClasses，但是这种情况出现的比较少
   public AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {
     //调用无参构造函数，会先调用父类GenericApplicationContext的构造函数
     //父类的构造函数里面就是初始化DefaultListableBeanFactory，并且赋值给beanFactory
     //本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner
     //scanner的用处不是很大，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的
     this();
     //把传入的类进行注册，这里有两个情况
     //传入传统的配置类
     //传入bean（虽然一般没有人会这么做）
     //我们这里把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean
     register(annotatedClasses);
     //刷新
     refresh();
   }
   ```

3. 调用父类AbstractApplicationContext的register方法

   ```java
   //读取配置文件，环境相关的东西
   StandardEnvironment {activeProfiles=[], defaultProfiles=[default], propertySources=[MapPropertySource {name='systemProperties'}, SystemEnvironmentPropertySource {name='systemEnvironment'}]}
   ```

4. refresh方法

   ```
   // Prepare this context for refreshing.
   			prepareRefresh();
   		//创建beanfactory，Beandefinition逻辑就在这里
   			// Tell the subclass to refresh the internal bean factory.
   			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
   //向beanfactory设置一些东西
   			// Prepare the bean factory for use in this context.
   			prepareBeanFactory(beanFactory);
   
   			try {
   				// Allows post-processing of the bean factory in context subclasses.
   				postProcessBeanFactory(beanFactory);
   //注册beanfactorypostprocessor
   				// Invoke factory processors registered as beans in the context.
   				invokeBeanFactoryPostProcessors(beanFactory);
   //注册beanpostprocessors
   				// Register bean processors that intercept bean creation.
   				registerBeanPostProcessors(beanFactory);
   //国际化配置
   				// Initialize message source for this context.
   				initMessageSource();
   //
   				// Initialize event multicaster for this context.
   				initApplicationEventMulticaster();
   
   				// Initialize other special beans in specific context subclasses.
   				onRefresh();
   
   				// Check for listener beans and register them.
   				registerListeners();
   				//实例化非懒加载单例Bean
   				// Instantiate all remaining (non-lazy-init) singletons.
   				finishBeanFactoryInitialization(beanFactory);
   
   				// Last step: publish corresponding event.
   				finishRefresh();
   			}
   ```



## 面试题

> [ApplicationContext和BeanFactory区别](https://www.imooc.com/article/264722)

* ApplicationContext单例对象适用，构建容器采取的策略是立即加载的方式
* BeanFactory只有getBean才会进行加载实例化

> [Spring生命周期](https://www.zhihu.com/question/38597960)



> [BeanDefinition生成流程](https://www.jianshu.com/p/9dd8cf463faa)

```
1.refresh();
2.ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
3.refreshBeanFactory();
4.AbstractRefreshableApplicationContext类核心方法
protected final void refreshBeanFactory() throws BeansException {
		if (hasBeanFactory()) {
			destroyBeans();
			closeBeanFactory();
		}
		//默认IOC容器的创建
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			beanFactory.setSerializationId(getId());
			customizeBeanFactory(beanFactory);
			//读取和解析文件
			loadBeanDefinitions(beanFactory);
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
		}
	}
```



> SpringAop原理