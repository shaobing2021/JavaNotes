## 测试

* 并发场景下邮件发送问题（令牌桶算法）
* 主键重复问题（使用雪花算法或者更优的）
* 致命点：多个线程对同一段操作共享数据的代码进行并发操作，从而出现并发安全问题
  * 分布式锁解决高并发安全问题
  * 协助方案：对于瞬时流量，并发请求进行限流
  * 辅助方案：集群(rabbitmq,redis)部署,提高高可用和稳定性
  * 数据库mysql做主备部署，一个master，多个slaver

> 细节

* 为什么未出现重复同一个人抢购同一商品，因为该商品状态被定时器改为-1
* 为什么会出现加锁失败，其实也不能说加锁失败，是因为锁过期了，设置时间太短

* 先扣减库存再生成订单，由于减完库存，生成订单失败则库存减了，但是订单并没有生成，而这里我使用try，catch只是将锁释放，则导致这个人还能抢到，但是这个人导致库存减了
* 而必须先减库存再生成订单否则，订单生成，但是无法扣减库存
* 使用mq的时候，java代码设置时间很大，而mq队列时间比较。而mq一开始队列和交换机生成好，则参数已经固定，需要删除重启tomcat