## Java

### ==和equals区别

```
1、java中equals和==的区别 值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
2、==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
3、equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。
4、==比较的是2个对象的地址，而equals比较的是2个对象的内容，显然，当equals为true时，==不一定为true。
记得重写equals方法
```

### [fina](https://www.cnblogs.com/chhyan-dream/p/10685878.html)l和[static](https://www.cnblogs.com/liujiarui/p/12499716.html)以及[abstract](https://zhuanlan.zhihu.com/p/147354504)关键字

> final（一旦定义就不能修改）

* 修饰引用：
  * 如果引用为基本数据类型，则该引用为常量，该值无法修改
  * 如果引用为引用数据类型，如对象，数组，则该对象，数组本身可以修改，但指向该对象或数组的地址引用不能修改
  * 如果引用是类的成员变量，则必须当场赋值，否则编译报错
* 修饰方法
  * 该方法无法被子类重写，但是可以被继承
* 修饰类
  * 断子绝孙类，无法被继承。例如String

final修饰的放在常量池里面，编译期间就已经确定

> static  静态的

* 只能修饰成员变量，不能修饰局部变量（静态非静态方法都不可以），因为**类中所有对象都共享**

* 静态代码块，执行顺序静态代码块—>非静态代码块—>构造方法，静态代码块在第一次new的时候执行一次。而非静态代码块每new一次就执行一次。非

* 一般不能修饰类，只能修饰内部类，那么静态内部类可以直接new，非静态内部类属于类模板里面的东西，只能先new父类实例才能new该类

  ```java
  public` `class` `StaticClassTest {
    ``public` `static` `void` `main(String[] args) {
      ``//静态内部类可以直接new
      ``StaticInner si=``new` `StaticInner();
      ``//非静态内部类需创建一个父类的实例，方能new
      ``StaticClassTest sct=``new` `StaticClassTest();
      ``Inner i=sct.``new` `Inner();
    ``}
      class  Inner{
      
      }
      static` `class` `StaticInner{
      
      }
  ```

* 静态方法和非静态方法：静态方法属于类本身，可以类名.方法名调用

* 静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法

> abstract   抽象的，不能实例化

* 不能用来修饰属性，因为abstract修饰的内容都是暂未被实现的，而当你int age，String name，申明变量的时候会给属性赋予初始值。
* 修饰类，不能实例化，由子类对象实例化
* 修饰方法只有声明，没有方法体。
* 抽象类中方法必须加上abstract，否则就实现。普通类中方法不能写abstract，因为方法不是抽象的

> [abstract和static问题]()

* static修饰方法是静态方法，直接被类调用
* abstract调用的是抽象方法，无方法体的方法，不能被直接调用

### 抽象类和接口

> 抽象类

* 抽象类是被用于继承的，final修饰代表不可修改，不可继承
* 抽象方法不能为private，final，因为一旦修饰，那么子类就没法进行覆盖，而abstract就是为了被覆盖，矛盾。
* 抽象方法不能为static，static方法是类模板本身的，直接通过类名调用
* 抽象类中可以有静态代码块和静态方法（需要有方法体）

> 接口

* 接口是给别人实现的，没有类继承所以就没有意义了，因此不能用private，protected。对于其成员变量默认为public static final修饰并且需要赋值，方法默认用public abstract修饰。

* 接口不可以有未赋值的变量

* 可以有静态方法
* 不可以有静态代码块，可以这么理解，静态代码块一般用来初始化变量的，而接口不可以有未赋值的变量

> 相同点

* 抽象类和接口都是一种规范

* 都不能被实例化
* 都可以包含方法的声明
* 都可以被继承，子类必须实现未实现的方法

> 抽象类和接口区别

* 但是抽象类可以有具体方法实现，但是在java8之后可以通过default进行修饰的方法也可以有实现。
* 接口里面方法默认就是public abstract，而抽象类可以用protected，default等修饰
* 他们都需要靠子类实现或者继承，接口支持多继承，但是抽象类不能多继承，只能实现一个父类。

![](https://img-blog.csdn.net/20170901095953175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2ppbmdxaWFubmloYW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### [内部类](https://www.zhihu.com/question/26954130)

### 重载和重写

重载：表示同一个类中有多个名称相同的方法，构成重载的条件

* 参数类型不同
* 参数个数不同
* 参数类型不同

重写：子类对父类方法的一个重写

* 方法名和参数列表必须相同
* 返回值小于父类
* 比父类抛出更少的异常
* 访问权限大于父类
* 被覆盖的方法是private，则不是重写，是定义一个新方法

## 计算机网络

[计算机网络](https://blog.csdn.net/iwanderu/article/details/103812828)

#### 七层协议

* 网络层：IP、ICMP、IGMP、ARP数据包
* 数据链路层：PPP协议   数据帧

#### 数据链路层

`基本问题`

* 封装成**帧**
* 透明传输：字节传输或者字符传输
* 差错校验

`PPP协议`

`MAC地址`

* 生成树算法

`交换机`

#### 网络层

##### IP、掩码计算广播地址

`基本问题：`

* 寻址
* 路由选择
* 分组长度

`ARP协议`

**有IP为什么还需要ARP，**因为传输到三层，路由层面东西用完了，有二层和物理层没封装，二层属于局域网内的寻址，需要ARP协议来继承协助封装以保证数据正常传输。

`RARP协议`

`ICMP协议`

* PING

`IGMP协议`

* 组播

`IP协议`

* `OSPF协议`根据带宽选择路径

* `RIP协议` 周期性广播(30s)路由表，选择路径的依据是最少的跳数，最大跳数是15跳

`IP地址划分`

* A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0

* B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255

* C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个

* D类IP地址第一个字节以“lll0”开始

#### 传输层

##### TCP

> 可靠传输

* 通过分片，将数据分成合适的数据块
* 编号进行发送，超时重传(时间计算)，选择确认（重传未被确认的数据报）

> 流量控制

* TCP连接每一方都有固定大小的缓存空间，该大小为接收端能够接收的数据。利用滑动窗口机制协商进行流量控制

> 拥塞控制

* 慢开始（成倍增长）和拥塞避免（线性增长）
* 快恢复（设置为原来的一半或者一半+3）

##### 三次握手

第一次客户端发送SYN=1 告诉服务器建立连接，seq为报文序列号

第二次服务器发送ACK=1确认建立连接，SYN=1建立连接

第三次客户端发送ACK=1确认建立连接

##### 四次挥手

第一次：客户端发送FIN进入关闭状态

第二次：服务器收到FIN之后，发送ACK报文，进入关闭状态

第三次：服务器断开连接，发送FIN报文，进入关闭状态

第四次：客户端接收FIN报文，发送ACK报文，等待关闭。服务器直接关闭

## 测试代码结果


