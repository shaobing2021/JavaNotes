## 多线程

#### 线程简介以及实现

##### 线程、进程、程序概念区别

参考：https://www.cnblogs.com/forzheng/p/8280925.html

> 进程

==进程==是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

一个程序，一个进程包含多个线程

> 线程

==线程==是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

Java默认有个2线程，2个，main和GC线程

每个线程在自己的工作内存交互，内存控制不当会造成数据不一致问题。

线程会带来额外开销，例如CPU调度时间，并发控制开销

> 并行与并发

并行指在同一时间点同时执行，并发是指在同一时间片段同时执行（多线程操作同一个资源）

进程之间相互独立，可实现并行，但线程不可以，多线程只能并发执行，实际还是顺执行，只是在同一时间片段，假似同时执行，cpu可以按时间切片执行，单核cpu同一个时刻只支持一个线程执行任务，多线程并发事实上就是多个线程排队申请调用cpu，cpu处理任务速度非常快，所以看上去多个线程任务说并发处理。

> Java能否开启线程？

```java
public synchronized void start() {
    if (this.threadStatus != 0) {
        throw new IllegalThreadStateException();
    } else {
        this.group.add(this);
        boolean started = false;

        try {
            this.start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    this.group.threadStartFailed(this);
                }
            } catch (Throwable var8) {
            }

        }

    }
}
//调用本地方法，底层C++，Java无法直接操作硬件
private native void start0();
```

##### 实现线程的三种方式

###### 第一种方式：继承Thread类

Thread类本身继承于Runable接口

1.自定义线程继承Thread类

2.重写run方法，编写线程体

3.创建线程对象，调用start方法启动线程

```java
public class ThreadImpl extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("run:"+i);
        }
    }
    public static void main(String[] args) {
        ThreadImpl thread = new ThreadImpl();
        thread.start();
      	//thread.setName();
        for (int i = 0; i < 200; i++) {
            System.out.println("main"+i);
        }
    }
}
```

下载commons-io-2.4包，实现多线程下载图片

```java
package thread;
import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.IOException;
import java.net.URL;
public class ThreadDownload extends Thread{
    private String url;
    private String name;
    public ThreadDownload(String url,String name){
        this.url = url;
        this.name = name;
    }
    @Override
    public void run() {
        Webdownloader webdownloader = new Webdownloader();
        webdownloader.download(url,name);
        System.out.println("filename:"+name);
    }
    public static void main(String[] args) {
        String u1 = "https://images2015.cnblogs.com/blog/331425/201607/331425-20160712105138029-1564953731.png";
        String u2 = "https://images2015.cnblogs.com/blog/331425/201705/331425-20170525160920122-280163435.png";
        String u3 = "https://img2018.cnblogs.com/blog/331425/201912/331425-20191209081336790-1292948571.jpg";
        String name = "2.jpg";
        ThreadDownload t1 = new ThreadDownload(u1, "1.jpg");
        ThreadDownload t2 = new ThreadDownload(u2, "2.jpg");
        ThreadDownload t3 = new ThreadDownload(u3, "3.jpg");
        t1.start();
        t2.start();
        t3.start();
    }
}
class Webdownloader{
    public void download(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常....");
        }
    }
}
```

###### 第二种方式：实现Runnable接口*

1. 定义Runnaable类实现Runnable接口
2. 实现run()方法，编写线程执行体
3. 创建线程对象，调用start()方法启动线程

```java
package thread;
public class ThreadImpl1 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 200; i++) {
            System.out.println("run:"+i);
        }
    }
    public static void main(String[] args) {
        ThreadImpl1 threadImpl1 = new ThreadImpl1();
        //此处使用静态代理
        new Thread(threadImpl1).start();
        for (int i = 0; i < 200; i++) {
            System.out.println("main:"+i);
        }
    }
}
```

###### 继承Thread和实现Runnable接口对比

相同点：均实现run方法

不同点：继承Thread类启动线程：子类对象.start()   （不推荐使用，避免OOP单继承局限性）

​				实现Runnable接口启动线程：传入目标对象+Thread对象.start()  （推荐使用，避免单继承局限性，方便同一个对象被多个线程使用）

###### 同一个对象被多个线程使用案例

```java
package thread;
public class ThreadTest implements Runnable {
    private int ticketNums = 10;
    @Override
    public void run() {
        while (true){
            if (ticketNums<=0){
                break;
            }
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } 	     System.out.println(Thread.currentThread().getName()+"--->第"+ticketNums--);
        }
    }
    public static void main(String[] args) {
        ThreadTest t = new ThreadTest();
        new Thread(t,"t1").start();
        new Thread(t,"t2").start();
        new Thread(t,"t3").start();
    }
}
结果：
t1--->第8
t3--->第10
t2--->第9
t1--->第7
t2--->第5
t3--->第6
t2--->第4
t1--->第3
t3--->第4
t2--->第2
t1--->第1
t3--->第0
t2--->第-1
```

问题：不安全

###### 多线程模拟龟兔赛跑

兔子和乌龟同时赛跑，兔子满足条件时将睡觉，乌龟赢得比赛。而此时winner！=null，因此最后输出game over；

```java
package thread;
public class Race implements Runnable {
    private static String winner;
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (Thread.currentThread().getName().equals("兔子") && (i&10)==0){
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            boolean flag = gameOver(i);
            if (flag){
                break;
            }
           System.out.println(Thread.currentThread().getName()+"--->跑了"+i+"步");
        }
    }
    private boolean gameOver(int steps){
        if (winner!=null){
            System.out.println("game over");
            return true;
        }
        if (steps>=100){
            winner = Thread.currentThread().getName();
            System.out.println("winner is " +winner);
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        Race t = new Race();
        new Thread(t,"兔子").start();
        new Thread(t,"乌龟").start();
    }
}

```

###### 第三种方式：实现Callable接口

1. 实现Callable接口，需要返回值类型
2. 重写call方法，需要抛出异常
3. 创建目标对象
4. 创建执行服务：Executors.newFixedThreadPool(池数量);
5. 提交执行 ：ser.submit(线程对象)
6. 获取结果：r1.get()会抛出异常
7. 关闭服务：ser.shutdownNow      和shutdowb区别？

```java
package com.roosevelt;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

@Slf4j(topic = "c.ThreadTest")
public class ThreadTest {
    public static void main(String[] args) {
        FutureTask futureTask = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                log.debug("call--running");
                Thread.sleep(100);
                return 100;
            }
        });
        new Thread(futureTask,"futuretask").start();
        try {
            log.debug("{}",futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```



```java
package thread;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

public class TestCallable implements Callable<Boolean> {
    private String url;
    private String name;
    public TestCallable(String url,String name){
        this.url = url;
        this.name = name;
    }
    @Override
    public Boolean call() throws Exception {
        Webdownloader webdownloader = new Webdownloader();
        webdownloader.download(url,name);
        System.out.println("filename:"+name);
        return true;
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        String u1 = "https://images2015.cnblogs.com/blog/331425/201607/331425-20160712105138029-1564953731.png";
        String u2 = "https://images2015.cnblogs.com/blog/331425/201705/331425-20170525160920122-280163435.png";
        String u3 = "https://img2018.cnblogs.com/blog/331425/201912/331425-20191209081336790-1292948571.jpg";
        String name = "2.jpg";
        ThreadDownload t1 = new ThreadDownload(u1, "1.jpg");
        ThreadDownload t2 = new ThreadDownload(u2, "2.jpg");
        ThreadDownload t3 = new ThreadDownload(u3, "3.jpg");
        ExecutorService ser = Executors.newFixedThreadPool(3);
        Future<?> r1 = ser.submit(t1);
        Future<?> r2 = ser.submit(t2);
        Future<?> r3 = ser.submit(t3);
        System.out.println(r1.get());
        ser.shutdownNow();
    }
}
class Webdownloader{
    public void download(String url,String name){
        try {
            FileUtils.copyURLToFile(new URL(url),new File(name));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("IO异常....");
        }
    }
}
```

#### Thread中的静态代理

先看手写静态代理：

首先有一个Marry接口，You类中实现结婚，WeddingCompany为You代理实现增强，You和WeddingCompany均实现Marry接口

Runnable接口，new Runnable实现run方法，Thread实现Runnable接口为实现增强

```
package proxy;
public class StaticProxy {
    public static void main(String[] args) {
        WeddingCompany company = new WeddingCompany(new You());
        company.HappyMarry();
    }
}
interface Marry{
    void HappyMarry();
}
class You implements Marry{
    @Override
    public void HappyMarry() {
        System.out.println("i marry , happy" );
    }
}
class WeddingCompany implements Marry{
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }
    @Override
    public void HappyMarry() {
        before();
        target.HappyMarry();
        after();
    }
    private void after() {
        System.out.println("结婚之后收钱");
    }
    private void before() {
        System.out.println("布置场景");
    }
}
```

#### Lamda表达式

优点：1.避免匿名内部类定义过多	2.代码简洁

函数接口定义：任何接口如果只包含一个抽象方法，那么它就是一个函数式接口

```java
public interface Runnable{
    public abstract void run();
}
```

对于函数式接口，可通过lambda表达式创建该接口的对象

典型用处：简化实现Runnable接口过程

##### Lamda表达式进化过程

```java
package lambda;

public class TestLambda {
    //2.静态内部类
    static class Like2 implements ILike{
        @Override
        public void lambda() {
            System.out.println("I like lambda2");
        }
    }
    public static void main(String[] args) {
        ILike like = new Like();
        like.lambda();
         like= new Like2();
         like.lambda();
        //3.局部内部类
        class Like3 implements ILike{
            @Override
            public void lambda() {
                System.out.println("I like lambda3");
            }
        }
        like = new Like3();
        like.lambda();
        //4.匿名内部类，没有类名称，借助接口或者父类
        like = new ILike(){
            @Override
            public void lambda() {
                System.out.println("i like lambda4");
            }
        };
        like.lambda();
        //5.lambda简化，接口只有这一个类？这个类只有这一个方法
        like = ()-> {
            System.out.println("i like lambda5");
        };
        like.lambda();
    }
}
//定义一个函数式接口
interface ILike{
    void lambda();//因为定义在接口，这是隐式声明，因此为抽象的
}
//1.实现类
class Like implements ILike{

    @Override
    public void lambda() {
        System.out.println("I like lambda");
    }
}
```

##### Lamda表达式简化过程

```java
package lambda;

public class TestLambda2 {
    public static void main(String[] args) {
        //简化1.去掉参数类型返回值
        ILove love = (a)->{
            System.out.println("i love u " + a);
        };
        love.love(1);
        //简化2.去掉花括号
        love = a-> System.out.println("i love u " + a);
        love.love(2);
        //总结lambda表达式只能有一行代码才能简化成一行，如果有多行，那么就用代码块
        //多个参数可以去掉参数类型，例如去掉int，要去掉都去掉，但是必须加上括号
//        love=(a,b)->{
//            System.out.println("i love" +a);
//            System.out.println("i love" +b);
//        };
    }
}
interface ILove{
    void love(int a);
    //void love （int a,int b）
}

```

#### 线程的六种状态

![线程六种状态](https://gitee.com/shaobing2021/typora/raw/master/img/20200728095812.jpg)

| 状态名称      | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | **初始状态**，线程刚被构建，但是还没有调用start()方法        |
| RUNNABLE      | **运行状态**，Java系统中将操作系统中的就绪和运行两种状态笼统地称为“运行中” |
| BLOCKED       | **阻塞状态**，表示线程阻塞于锁                               |
| WAITTING      | **等待状态**，表示线程进入等待状态，进入该状态表示当前线程做出一些特定动作（通知或者中断） |
| TIME_WAITTING | **超时等待状态**，该状态不同于等待状态，它可以在指定的时间后自行返回 |
| TERMINATED    | **中止状态**，表示当前线程已经执行完毕                       |

* New状态   new Thread(){};
* 

#### 测试

```java
package com.roosevelt;
import lombok.extern.slf4j.Slf4j;
import javax.swing.*;
@Slf4j(topic = "c.ThreadTest")
public class ThreadTest {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                log.debug("running....");
            }
        };
      //New
        Thread t2 = new Thread("t2") {
            @Override
            public void run() {
                    while (true) {

                    }
            }
        };
        t2.start();//Runable
        Thread t3 = new Thread("t3") {
            @Override
            public void run() {
                log.debug("t3 over.....");
            }
        };
        t3.start();//Terminate
        Thread t4 = new Thread("t4") {
            @Override
            public void run() {
                synchronized (ThreadTest.class){
                    try {
                        Thread.sleep(30000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t4.start();//sleep,timed_waiting
        Thread t5 = new Thread("t5") {
            @Override
            public void run() {
                try {
                    t2.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t5.start();
        Thread t6 = new Thread("t6") {
            @Override
            public void run() {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (ThreadTest.class){
                }
            }
        };
        t6.start();
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("t1{}",t1.getState());
        log.debug("t2{}",t2.getState());
        log.debug("t3{}",t3.getState());
        log.debug("t4{}",t4.getState());
        log.debug("t5{}",t5.getState());
        log.debug("t6{}",t6.getState());
    }
}
/*
12:43:11 [t3] c.ThreadTest - t3 over.....
12:43:11 [main] c.ThreadTest - t1NEW
12:43:11 [main] c.ThreadTest - t2RUNNABLE
12:43:11 [main] c.ThreadTest - t3TERMINATED
12:43:11 [main] c.ThreadTest - t4TIMED_WAITING
12:43:11 [main] c.ThreadTest - t5WAITING
12:43:11 [main] c.ThreadTest - t6BLOCKED
 */
```

##### 线程停止

思路：设置标志位，当t线程一直跑的时候，让main线程跑到250调用stop方法，将flag设置为false，从而使t线程停止。

```java
package runnable;

//使用标志位让线程停止，不建议使用destroy或者stop等过时方法
public class TestStop implements Runnable{
    //1.设置标志位
    private boolean flag = true;
    @Override
    public void run() {
        int i = 0;
        while (flag){
            System.out.println("run..thread..." +i++);
        }
    }
    public void stop(){
        this.flag = false;
    }

    public static void main(String[] args) {
        TestStop t = new TestStop();
        new Thread(t).start();
        for (int i = 0; i < 500; i++) {
            System.out.println("main"+i);
            if (i==250){
                t.stop();
                System.out.println("线程停止");
            }
        }
    }
}

```

##### 线程休眠

sleep指定的是当前线程阻塞的毫秒数，其存在InterruptedException。sleep时间到达之后，线程进入就绪状态

主要作用：模拟网络延时例如抢票，模拟倒计时如下代码

每个对象都有一个锁，sleep不会释放锁。

```java
package runnable;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.SimpleFormatter;
public class TestSleep {
    public static void main(String[] args) throws InterruptedException {
        Date start = new Date(System.currentTimeMillis());
        while (true){
            Thread.sleep(1000);
            System.out.println(new SimpleDateFormat("HH:mm:ss").format(start));
            start = new Date(System.currentTimeMillis());
        }
    }
    public static void tenDown() throws InterruptedException {
        int num = 10 ;
        while (true){
            Thread.sleep(1000);
            System.out.println(num--);
            if (num<=0){
                break;
            }
        }
    }
}

```

##### 线程礼让

礼让线程，让当前正在执行的线程暂停，但不阻塞

将线程从运行状态转为就绪状态

让cpu重新调度，礼让不一定成功，看cpu心情

```java
class MyYield implements Runnable{
    public static void main(String[] args) {
        MyYield myYield = new MyYield();
        new Thread(myYield,"a").start();
        new Thread(myYield,"b").start();
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+":线程开始");
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+":线程停止");
    }
}
```

##### 线程插队

Join合并线程，待此线程执行完毕后，再执行其他线程，其他线程阻塞

代码分析：main线程和t线程同时跑，当main线程跑到一定程度，执行t.join，则会让t线程跑完才执行main线程

```java
package runnable;
public class TestJoin  implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 3000; i++) {
            System.out.println("线程vip:"+i);
        }
    }
    public static void main(String[] args) throws InterruptedException {
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();
        for (int i = 0; i < 100; i++) {
            if (i==50){
                System.out.println("插队开始");
                thread.join();
            }
            System.out.println(Thread.currentThread().getName()+i);
        }
    }
}

```

##### 获取线程状态

死亡后不能再去启动

```java
package runnable;
import java.lang.Thread.State;
public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("------");
        });
        State state = thread.getState();
        System.out.println(state);//NEW
        thread.start();
        state= thread.getState();//RUNNABLE
        System.out.println(state);
        while (state!= State.TERMINATED){
            Thread.sleep(100);
            state = thread.getState();
            System.out.println(state);//TIMED_WAITING
        }
        state = thread.getState();
        System.out.println(state);//TIMED_WAITING
    }
}
```

##### 线程优先级

线程调度器监控程序中启动后进入就绪的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。

优先级低只意味着获得调度的概率低，并不是优先级低就不会被调用，取决于CPU调度

```
package runnable;
public class TestPriority {
    public static void main(String[] args) {
      System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
        MyPriority myPriority = new MyPriority();
        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        t1.start();
        t2.setPriority(1);
        t2.start();
        t3.setPriority(4);
        t3.start();
        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();
    }
}
class MyPriority implements Runnable{
    @Override
    public void run() {
      System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
    }
}
```

##### 守护线程

线程分为用户线程和守护线程

用户线程如：main线程

守护线程如:gc垃圾回收，后台记录操作日志，监控内存等。

默认线程均为用户线程，虚拟机不用等待守护线程执行完毕

代码分析：God死循环，但是设置为守护线程，未执行完毕也会在用户线程执行完毕之后关闭

```
package runnable;

public class TestDaemon {
    public static void main(String[] args) {
        God god = new God();
        You you = new You();
        Thread thread = new Thread(god);
        thread.setDaemon(true);//默认为false表示是用户线程，正常线程都是用户线程;
        thread.start();
        new Thread(you).start();
    }
}
class God implements Runnable{
    @Override
    public void run() {
        while (true){
            System.out.println("god bless u");
        }
    }
}
class You implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 365; i++) {
            System.out.println("happy live");
        }
        System.out.println("---byebye---");
    }
}
```

#### 线程同步

**并发**：同一个对象被多个线程同时操作

队列和锁保证线程同步安全

引发问题：一个线程有锁会导致其他需要此锁的线程挂起；在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；高优先级线程等待一个优先级低的线程释放锁，导致优先级倒置，引起性能问题

##### 线程不安全情况：

代码分析：

###### 1.抢票不安全

由于每个线程均有自己的工作内存，因此拿到票在自己的工作区域内，会导致不安全问题。

###### 2.银行取钱导致线程不安全

```java
package syn;
public class UnsafeBuyTicket {
    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        new Thread(buyTicket,"a").start();
        new Thread(buyTicket,"b").start();
        new Thread(buyTicket,"c").start();
    }
}
class BuyTicket implements Runnable{
    private Integer tikcket = 10 ;
    boolean flag = true;
    @Override
    public void run() {
        while (flag){
            buy();
        }
    }
    public void buy(){
        if (tikcket<=0){
            flag = false;
            return ；
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+"买到票"+tikcket--);
    }
}
```

```java
package syn;

public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account(100, "结婚基金");
        Drawing i = new Drawing(account, 50, "i");
        Drawing g = new Drawing(account, 100, "g");
        i.start();
        g.start();
    }
}
class Account{
     int money;
     String name;

    public Account(int money, String name) {
        this.money = money;
        this.name = name;
    }
}
class Drawing extends Thread{
    Account  account;
    int drawingMoney;
    int money;
    String name;
    public Drawing(Account account,int drawingMoney,String  name){
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;

    }

    @Override
    public void run() {
        if (account.money-drawingMoney<0){
            System.out.println(Thread.currentThread().getName()+"not enough money");
            return;
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        account.money -=drawingMoney;
        money+=drawingMoney;
        System.out.println(account.name+"余额："+account.money);
        //Thread.currentThread.getName() = this.getName();
        System.out.println(this.getName()+"手里的钱:"+money);
    }
}
```

###### 3.ArrayList不安全

ArrayList为什么不安全：当多个线程向里面添加数据，

```java
package syn;
import java.util.ArrayList;
public class UnsafeList {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
               list.add(Thread.currentThread().getName());
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}

```

具体原因分析:ArrayList不安全详解

```java
  public boolean add(E e) {       
        ensureCapacity(size + 1);  // Increments modCount!! 
        elementData[size++] = e;    
        return true;    
    }  
https://blog.csdn.net/zhangxin961304090/article/details/46804065?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1
```

list.size小于1000原因在于不同e同时赋值给size，而此时size未正确++。因此会出现null情况

数组越界情况：当A线程刚好执行完ensureCapacity，此时刚好达到临界即将需要扩容，B线程执行完毕size++操作，那么A线程再执行size++就出现IndexOutOf问题。

#### Synchronized、Lock

##### 同步方法

synchronized方法控制对“对象”的访问，**每个对象对应一把锁**，每个synchronized方法获得该方法对象的锁才能执行，否则线程会阻塞。

缺陷：若将一个大方法神明为synchronized将会影响效率。

方法里面需要修改的内容才需要锁，锁的太多，浪费资源。只读不需要锁

##### 同步块?

synchronized(obj){}

Obj称之为同步监视器，Obj可以是任何对象但是推荐使用共享资源作为同步监视器

同步方法无需指定同步监视器，因为同步方法的同步监视器是this，即对象本身，或者是class（反射内容）

案例分析：

1.抢票锁住

注意：synchronized锁住this的原因在于，此处实现Runnable接口，不同线程均操作buyTicket，锁住buyTicket.run即可

```java
  public synchronized void buy()
```

2.银行取钱锁

分析：由于使用extends Thread类，有两个Drawing对象，线程持有的并不是同一把锁，因此此处不能锁住run 方法。需使用同步代码块，两个对象操作的均为account对象，锁住account

```java
class Drawing extends Thread{
    Account  account;
    int drawingMoney;
    int money;
    public Drawing(Account account,int drawingMoney,String  name){
        super(name);
        this.account = account;
        this.drawingMoney = drawingMoney;
    }
    @Override
    public  void run() {
        synchronized (account){
            if (account.money-drawingMoney<0){
                System.out.println(Thread.currentThread().getName()+"not enough money");
                return;
            }
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            account.money -=drawingMoney;
            money+=drawingMoney;
            System.out.println(account.name+"余额："+account.money);
            //Thread.currentThread.getName() = this.getName();
            System.out.println(this.getName()+"手里的钱:"+money);
        }
    }
}
```

3.锁住ArrayList

不同线程操作list对象，锁住list即可，留有一点

```java
public class UnsafeList {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            new Thread(()->{
                synchronized (list){
                    list.add(Thread.currentThread().getName());
                }
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}

```

JUC中的ArrayList

```java
package syn;
import java.util.concurrent.CopyOnWriteArrayList;
public class TestJUC {
    public static void main(String[] args) {
        CopyOnWriteArrayList list = new CopyOnWriteArrayList<String>();
        for (int i = 0; i < 10000; i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
```

##### 死锁

互相等对方锁释放

分析：由于a，b分别使用镜子和口红，导致之后a，b无法再使用空红和镜子，双发均僵持住，造成死锁

```java
package syn;

public class DeadLock {
    public static void main(String[] args) {
        Makeup a = new Makeup(0, "a");
        Makeup b = new Makeup(0, "b");
        a.start();
        b.start();
    }
}
//口红
class Lipstick{

}
//镜子
class Mirror{

}
class Makeup extends Thread{
    //需要的资源只有一份,因此使用static来保证只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();
    int choice;
    String girlName;
    Makeup(int choice,String girlName){
        this.choice = choice;
        this.girlName = girlName;
    }

    @Override
    public void run() {
        makeup();
    }
    private void makeup(){
        if (choice==0){
            synchronized (lipstick){
                System.out.println(this.girlName+"获得口红的锁");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (mirror){
                    System.out.println(this.girlName+"获得镜子的锁");
                }
            }
        }else {
            synchronized (mirror){
                System.out.println(this.girlName+"获得镜子的锁");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lipstick){
                    System.out.println(this.girlName+"获得口红的锁");
                }
            }

        }
    }
}
```

造成死锁的四个条件：

![造成死锁的四个条件](https://gitee.com/shaobing2021/typora/raw/master/img/20200728095813.png)

上述死锁代码解锁：不嵌套synchronized即可

##### Lock锁

显示开启显示关闭，注意代码有异常的时候需要将unlock放入finaly

```java
package syn;

import java.util.concurrent.locks.ReentrantLock;

public class TestLock {
    public static void main(String[] args) {
        TestLock1 t = new TestLock1();
        new Thread(t).start();
        new Thread(t).start();
        new Thread(t).start();
    }
}
class TestLock1 implements Runnable{
    int ticketNums = 10;
    private final ReentrantLock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true){
            try {
                lock.lock();
                if (ticketNums>0){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
                }else {
                    break;
                }
            }finally {
                lock.unlock();
            }
        }
    }
}
```

##### 两者区别：

Lock是显式锁（手动开启和关闭）Synchronized是隐式锁，出了作用域自动释放

Lock只有代码块锁，synchronized有代码块锁和方法锁

使用Lock锁，JVM花费更少时间调度线程，性能更好

Lock>同步代码块>同步方法

#### 线程通信

生产者消费者共享同一资源，之间互相依赖，互为条件

解决方式1:添加缓冲区，管程法

解决方式2：信号灯法

线程通信的四种方式：

* 管道
* 命名管道
* 信号
* 消息队列

##### 管程法

生产者不断生产，若缓冲区满了则进行等待，生产之后唤醒缓冲进程

消费者不断消费，若缓存区无则进行等待，消费之后唤醒缓冲进程

```java
package syn;
public class TestPc  {
    public static void main(String[] args) {
        SynContainer con = new SynContainer();
        new Productor(con).start();
        new Consumer(con).start();
    }
}
class Productor extends Thread{
    SynContainer container;
    public Productor(SynContainer container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("生产勒"+i+"只鸡");
            container.push(new Chicken(i));
        }
    }
}
class Consumer extends Thread{
    SynContainer container;
    public Consumer(SynContainer container) {
        this.container = container;
    }
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费勒"+container.pop().id+"只鸡");
        }
    }
}
class Chicken{
    int id;

    public Chicken(int id) {
        this.id = id;
    }
}
class SynContainer{
    Chicken[] chickens = new Chicken[10];
    int count = 0;
    public synchronized void push(Chicken chicken){
        //生产者进行等待
        if (count==chickens.length){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        chickens[count] = chicken;
        count++;
        this.notifyAll();
    }
    public synchronized Chicken pop(){
        if (count==0){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        count--;
        Chicken chicken = chickens[count];
        this.notifyAll();
        return chicken;
    }
}
```

##### 信号灯法

利用标志位解决

```java
package syn;
public class TestPC1 {
    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Watcher(tv).start();
    }
}
class Player extends Thread{
    TV tv;
    public Player(TV tv) {
        this.tv = tv;
    }
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i%2==0){
                this.tv.play("快乐大本营");
            }else {
                this.tv.play("抖音");
            }
        }
    }
}
class Watcher extends Thread{
    TV tv;
    public Watcher(TV tv) {
        this.tv = tv;
    }
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}
class TV{
    String voice;
    boolean flag = true;
    public synchronized void play(String voice){
        if (!flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("演员表演勒:"+voice);
        this.notifyAll();
        this.voice = voice;
        this.flag=!this.flag;
    }
    public synchronized void watch(){
        if (flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了:"+voice);
        this.notifyAll();
        this.flag = !this.flag;
    }
}
```

#### 线程池

类似Callable实现线程

```java
package syn;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TestPool {
    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(10);
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.shutdown();
    }
}
class MyThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

## JUC

学习内容：

![image-20200522082933737](https://gitee.com/shaobing2021/typora/raw/master/img/20200728095814.png)

`Runnable`没有返回值，效率相比Callable低

> 并行与并发

```
package juc;

public class Test {
    public static void main(String[] args) {
        System.out.println(Runtime.getRuntime().availableProcessors());
        //双核四线程
    }
}

```

并发编程本质：充分利用CPU资源

### 多线程回顾

线程的六个状态

```
Thread.State：
//新生
NEW,
//运行
RUNNABLE,
//阻塞
BLOCKED,
//等待，死死的等
WAITING,
//超时等待
TIMED_WAITING,
//终止
TERMINATED;
```

#### wait和sleep区别

|          |    wait    |       sleep        |
| :------: | :--------: | :----------------: |
|    类    |   Object   |       Thread       |
|    锁    |   会释放   | 睡觉了，不会释放锁 |
| 使用范围 | 同步代码块 |      任意位置      |



```
通常使用该方法休眠
import java.util.concurrent.TimeUnit;
TimeUnit.DAYS.sleep(1);
```



#### Synchronized抢票

https://cloud.tencent.com/developer/article/1465413

```
package juc;


public class Test {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(()->{
          for(int i = 0;i<20;i++){
              ticket.sale();
        }
      },"a").start();
        new Thread(()->{
            for(int i = 0;i<20;i++){
                ticket.sale();
            }
        },"b").start();
        new Thread(()->{
            for(int i = 0;i<20;i++){
                ticket.sale();
            }
        },"c").start();
    }
}
class Ticket{
    private int ticket = 50;
    private int count =0;
    public synchronized void sale(){
        if (ticket>=0){
            System.out.println(Thread.currentThread().getName()+"卖出了："+count+++"还剩:"+(ticket--));
        }
    }
}
```

Lock锁




![image-20200522100156986](https://gitee.com/shaobing2021/typora/raw/master/img/20200728095815.png)

#### Lock

* 公平锁：先来后到
* 非公平锁：默认，允许插队

```java
public ReentrantLock() {
    this.sync = new ReentrantLock.NonfairSync();
}

public ReentrantLock(boolean fair) {
		//返回公平锁，非公平锁
    this.sync = (ReentrantLock.Sync)(fair ? new ReentrantLock.FairSync() : new ReentrantLock.NonfairSync());
}
```

代码

```java
package juc;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class Test1 {
    public static void main(String[] args) {
        Ticket1 ticket = new Ticket1();
        new Thread(()->{
          for(int i = 0;i<20;i++) ticket.sale();
      },"a").start();
        new Thread(()->{
            for(int i = 0;i<20;i++) ticket.sale();
        },"b").start();
        new Thread(()->{
            for(int i = 0;i<20;i++){
                ticket.sale();
            }
        },"c").start();
    }
}

/**
 * Lock三部曲
 * 1.new ReentrantLock()
 * 2.lock.lock()
 * 3.try-catch-finally   lock.unlock
 */
class Ticket1{
    private int ticket = 50;
    private int count =0;
    Lock lock = new ReentrantLock();
    public synchronized void sale(){
        //加锁4ock.lock();
				lock.tryLock();
        try {
            if (ticket>=0){
                System.out.println(Thread.currentThread().getName()+"卖出了："+count+++"还剩:"+(ticket--));
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //解锁
            lock.unlock();
        }
    }
}
```

> Synchronized和Lock区别

| 区别 | Synchronized                         | Lock                                         |
| ---- | ------------------------------------ | -------------------------------------------- |
|      | 内置的关键字                         | Java类                                       |
|      | 无法获取锁状态                       | 可以判断是否获取到了锁                       |
|      | 会自动释放锁                         | 必须手动释放锁，不释放则死锁                 |
|      | 线程1（获得锁阻塞），线程2(一直等待) | 不一定等待（tryLock）                        |
|      | 可重入锁，不可以中断，非公平         | 可重入锁，可以判断锁，非公平(可设置fair属性) |
|      | 适合锁少量代码同步问题               | 锁大量同步代码                               |
|      | 代码块锁和方法锁                     | 只有代码块锁                                 |

***可重入***就是说某个线程已经获得某个锁,可以再次获取锁而不会出现死锁

#### 传统生产者消费者问题

单例模式，排序算法，生产者消费者问题，死锁

Synchronized wait notify

```java
package juc;

/**
 * 生产者和消费者问题！
 */
public class Test2 {
    public static void main(String[] args) {
        Ticket2 ticket2 = new Ticket2();
        new Thread(()->{
            for (int i =0;i<30;i++){
                try {
                    ticket2.add();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"add").start();
        new Thread(()->{
            for (int i =0;i<30;i++){
                try {
                    ticket2.decrease();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"reduce").start();
    }
}
//关键三部曲
class Ticket2{
    private int ticket  = 0;
    public synchronized void add() throws InterruptedException {
        //1.等待
        if (ticket!=0){
            this.wait();
        }
        //2.业务
        ticket++;
        System.out.println(Thread.currentThread().getName()+"-->"+ticket);
        //3.通知
        this.notify();
    }
    public synchronized void decrease() throws InterruptedException {
        if (ticket==0){
            this.wait();
        }
        ticket--;
        System.out.println(Thread.currentThread().getName()+"-->"+ticket);
        this.notify();
    }
}
```

虚假唤醒问题

```
   synchronized (obj) { 
   while (<condition does not hold> and <timeout not exceeded>) { 
   long timeoutMillis = ... ; // recompute timeout values int nanos = ... ; 					obj.wait(timeoutMillis, nanos);
   } 
   ... // Perform action appropriate to condition or timeout } 
```

##### 原因：

假设AB线程对ticket实现增加操作，CD线程对tciket实现减少操作，A进入之后实现增加，B进入阻塞，A唤醒了B，此使B执行完if语句就会执行if外面语句，因此实现增加操作

##### 解决方式：

使用while，重新判断是否需要等待

#### JUC解决生产者消费者问题

通过Lock找到Condition

| 方式 |    synchronized     | lock   |
| ---- | :-----------------: | ------ |
| 等待 |        wait         | await  |
| 唤醒 | notify（Condition） | signal |

点开代码实现

```
  class BoundedBuffer<E> {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(E x) throws InterruptedException {
     lock.lock(); try {
       while (count == items.length)
         notFull.await();
       items[putptr] = x;
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();
     } finally { lock.unlock(); }
   }

   public E take() throws InterruptedException {
     lock.lock(); try {
       while (count == 0)
         notEmpty.await();
       E x = (E) items[takeptr];
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally { lock.unlock(); }
   }
 } 
```

解决抢票问题

```java
package juc;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
/**
 * 生产者和消费者问题！
 */
public class Test2 {
    public static void main(String[] args) {
        Ticket2 ticket2 = new Ticket2();
        new Thread(()->{
            for (int i =0;i<30;i++){
                try {
                    ticket2.add();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"add").start();
        new Thread(()->{
            for (int i =0;i<30;i++){
                try {
                    ticket2.decrease();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"reduce").start();
        new Thread(()->{
            for (int i =0;i<30;i++){
                try {
                    ticket2.decrease();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"reduce1").start();
        new Thread(()->{
            for (int i =0;i<30;i++){
                try {
                    ticket2.add();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"add1").start();
    }
}
//关键三部曲
class Ticket2{
    private int ticket  = 0;
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    public  void add() throws InterruptedException {
        lock.lock();
        try {
            //1.等待
            while (ticket!=0){
                condition.await();//加锁
            }
            //2.业务
            ticket++;
            System.out.println(Thread.currentThread().getName()+"-->"+ticket);
            //3.通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }
    public  void decrease() throws InterruptedException {
        lock.lock();
        try {
            //1.等待
            while (ticket == 0) {
                condition.await();//加锁
            }
            //2.业务
            ticket--;
            System.out.println(Thread.currentThread().getName() + "-->" + ticket);
            //3.通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

##### lock和synchronized对比

两者均解决了生产者消费者问题，为和需要Condition？

* Condition精准唤醒，使线程有序执行

### 锁详解

锁对象到底是什么？

```
package juc;

import java.util.concurrent.TimeUnit;

public class Test4 {
    /**
     * 1.2. a,b:永远先执行a：因为a，b同时执行的时候，突然main线程sleep 1s，此时进入了a方法体内，尽管a可能也睡眠了4s， 但是由于锁住了phone对象，因此不会导致b线程执行
     * 3.增加了一个普通方法：由于a睡了4s，c可以过1s后直接运行，因此执行c
     * 4.a，d使用两个不同对象，两个同步方法  输出：a,d
     * 5.如果增加static，那么e，f，由于e锁住了类，因此先输出e,尽管e锁住了几秒
     * 6.g，普通同步方法，
     * @param args
     */
    public static void main(String[] args) {
        Phone phone = new Phone();
        Phone phone1 = new Phone();
        new Thread(()->{
            phone.printa();
        },"a").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(()->{
            phone.printb();
        },"b").start();
        new Thread(()->{
            phone.printc();
        },"c").start();
        new Thread(()->{
            phone1.printd();
        },"d").start();
        new Thread(()->{
            phone.printe();
        },"e").start();
        new Thread(()->{
            phone1.printf();
        },"f").start();
    }
}
class Phone{
    //synchronized锁的对象使方法的调用者
    public synchronized  void printa(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("printa");
    }
    public synchronized void printb(){
        System.out.println("printb");
    }
    //此处没有锁
    public  void printc(){
        System.out.println("printc");
    }
    public synchronized void printd(){
        System.out.println("printd");
    }
    //static 静态方法，类一加载就有了，本质就是类Phone，被锁住的是Class对象
    public  static  synchronized void printe(){
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("printe");
    }
    //锁的Class对象
    public  static  synchronized void printf(){
        System.out.println("printf");
    }
    //锁的调用者
    public  synchronized void printg(){
        System.out.println("printg");
    }
}
```

> 小结

通常main线程顺序执行，

1.synchronized锁住的是this对象，需要锁的影响

2.不加synchronized则是普通方法，不是同步方法，不受锁的影响，因此对象被没被锁住，不需要排队

3.如果锁住的不是同一个对象，那么输出顺序不一定

4.如果增加static，则锁住的是Class类，即便是不同对象，也会被锁住

5.一个静态的同步方法，一个普通的同步方法,两个锁无关

### 集合类不安全

List问题

注意Vecotor底下有set，list还有一个bolkedqueue

```java
package juc;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;

public class Test5 {
    public static void main(String[] args) {
//        List<String> strings = Arrays.asList("1", "2", "3");
//        strings.forEach(System.out::println);
        ArrayList<Object> list = new ArrayList<>();  // 不安全 19751
      // new HashSet<>();
      //Collections.synchronizedSet(new HashSet<>());
      //new CopyonWriterArraySet<>();
//        Vector<Object> list = new Vector<>();  //19134
//        List<String> list = Collections.synchronizedList(new ArrayList<>());
//        List<String> list = new CopyOnWriteArrayList<>();
        //CopyOnWrite 写入时复制，多个线程调用的时候，固定的，写入（覆盖）
        //避免写入覆盖问题，造成
        //读写分离，相比Vector牛逼在哪里？Vector用的是synchronize，而copyOnwrite 用的是lock锁
        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                list.add(UUID.randomUUID().toString().substring(0,5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
        for (int i = 0; i < 00; i++) {
                list.add(UUID.randomUUID().toString().substring(0,5));
        }
        System.out.println(list.size());
    }
}
```

##### HashSet底层

HashSet不安全

```java
			// new HashSet<>();
      //Collections.synchronizedSet(new HashSet<>());
      //new CopyonWriterArraySet<>();
```

```
public HashSet() {
    this.map = new HashMap();
}
public boolean add(E e) {
        return this.map.put(e, PRESENT) == null;
    }
    private static final Object PRESENT = new Object();
```

##### Map不安全

```
// new HashMap<>();
      //Collections.synchronizedMap(new HashMap<>());
      //new ConcurrentHashMap<>();
```

### Callable

和Thread区别：

1. 可以有返回值
2. 可以抛出异常
3. 方法不同，run()/call()
4. 支持泛型

```java
package juc;
import java.util.HashMap;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
public class Test6 {
    public static void main(String[] args) {
//        new Thread().start();
        MyThread thread = new MyThread();
        FutureTask futureTask = new FutureTask(thread);//适配类
        new Thread(futureTask,"A").start();
         new Thread(futureTask,"B").start();//结果会被缓存，只输出一次
        String o = null;
        try {
          //get方法可能造成阻塞，耗时的操作，把他放到最后一行，使用异步通信处理
             o = (String) futureTask.get();//抛出异常，同时返回Callable接口返回值
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        System.out.println(o);
    }
}
class MyThread implements Callable<String>{
    @Override
    public String call() throws Exception {
        System.out.println("call...");
        return "hello";
    }
}
```

细节：

1. 有缓存
2. 结果可能需要等待，会阻塞

### 三大辅助类

#### CountDownLatch

减法计数器

```java
package juc;

import java.util.concurrent.CountDownLatch;

public class Test7 {
    public static void main(String[] args) {
      //1.给CountDownLatch初始化
        CountDownLatch countDownLatch = new CountDownLatch(8);
        for (int i = 0; i <= 6; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"Go");
              //2.每次有线程调用，则执行的线程数-1
                countDownLatch.countDown();
            },String.valueOf(i)).start();
        }
        try {
          //3.关闭门，计数为0才会继续往下走
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Close Door");
    }
}
```

- 使用给定*计数*初始化`CountDownLatch` 。所述[`await`](#await())方法阻塞，直到当前计数达到零由于的调用[`countDown()`](#countDown())方法，之后所有等待的线程被释放和任何后续调用[`await`](#await())立即返回。这是一次性现象 -  计数无法重置。如果您需要重置计数的版本，请考虑使用[`CyclicBarrier`](CyclicBarrier.html) 。

#### CyclicBarrier

加法计数器

```java
package juc;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
public class Test8 {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
            System.out.println("召唤神龙");
        });
        for (int i = 1; i <= 7; i++) {
            int temp = i;//jdk1.8之后不需要写final
            //lambda能操作到i吗，不能，因为其本质是匿名内部类,涉及JVM知识
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+":"+temp);
                try {
                    //等待7个线程执行完。没有7个则会一直等待
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}

```

#### semaphore

信号量

```java
package juc;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
/**
 * 假设6辆车抢3个车位
 */
public class Test9 {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);//
        for (int i = 0; i < 6; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();//得到停车位，如果已经满了，等待被释放
                    System.out.println(Thread.currentThread().getName()+"抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName()+"离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();//释放停车位，唤醒等待的线程
                }

            },String.valueOf(i)).start();
        }
    }
}
```

作用：多个共享资源互斥的使用！并发限流，控制最大的线程数！

### ReadWriteLock

读写锁

- `ReadWriteLock`维护一对关联的[`locks`](Lock.html) ，一个用于只读操作，另一个用于写入。 只要没有[写入](#readLock())器， [read  lock](#readLock())可以由多个读取器线程同时保持。 [write  lock](#writeLock())是独家的。

编写代码：发现不用Lock，在插入时候发生安全问题

```java
package juc;

import java.util.HashMap;
import java.util.Map;
//出现问题：put的时候会发生其他数据也插入进来
public class Test10 {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        //写入
        for (int i = 0; i < 10; i++) {
            int temp = i;
            new Thread(()->{
                myCache.put(temp+"",temp);
            },String.valueOf(temp)).start();
        }
        for (int i = 0; i < 10; i++) {
            int temp = i;
            new Thread(()->{
                myCache.get(temp+"");
            },String.valueOf(temp)).start();
        }
    }
}
/**
 * 自定义缓存
 */
class MyCache{
    //volatile 只能保证可见性，不能保证原子性
    private volatile Map<String,Object> map = new HashMap<>();
    //只有一个数据能够写
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"写入"+key);
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"写入ok");
    }
    //可以多个数据一起读
    public void get(String key){
        System.out.println(Thread.currentThread().getName()+"读取"+key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName()+"读取ok");
    }
}
```

### 阻塞队列

#### 概念

> 意义：之前线程的wait和notify我们程序员需要自己控制，但有了这个阻塞队列之后我们程序员就不用担心了，阻塞队列会自动管理。

阻塞：

队列：FIFO

写入：如果队列满了，就必须阻塞等待

取：如果队列是空的，必须阻塞等待生产

BlockingQueue：与list、set同级目录，实现类有array、linked

Collection

- set
- list
- queue
  - Deque:双端队列
  - AbstractQueue：非阻塞队列
  - BlockingQueue：阻塞队列
    - LinkedBlockingQueue
    - ArrayBlockingQueue

#### 四组API

1. ArrayBlockingQueue

```java
package juc;

import java.util.concurrent.ArrayBlockingQueue;

public class Test11 {
    public static void main(String[] args) {

        test();
    }
    public static void test(){
        //队列大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
        boolean a = arrayBlockingQueue.add("a");
        boolean ab = arrayBlockingQueue.add("b");
        boolean d = arrayBlockingQueue.add("c");
//        arrayBlockingQueue.add("d");报错，queue full

        System.out.println(a);

        System.out.println("---------");
        System.out.println(arrayBlockingQueue.remove());
        System.out.println(arrayBlockingQueue.remove());
        System.out.println(arrayBlockingQueue.remove());
//        System.out.println(arrayBlockingQueue.remove());  抛出异常
    }
}
```

1. 不会抛出异常

```java
public static void test1(){
    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
    boolean a = arrayBlockingQueue.offer("a");
    boolean b = arrayBlockingQueue.offer("b");
    boolean c = arrayBlockingQueue.offer("c");
    boolean d = arrayBlockingQueue.offer("d");//返回false
    System.out.println(a);
    System.out.println(d);
    System.out.println("---------");
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.poll());//返回null 
}
```

1. 阻塞等待（一直等待，到有元素被移除再进去）

```java
 public static  void test2(){
        ArrayBlockingQueue<Object> que = new ArrayBlockingQueue<>(3);
        try {
            que.put("a");
            que.put("b");
            que.put("c");
//            que.put("d");//程序不动了
            Object take = que.take();
            Object take1 = que.take();
            Object take2 = que.take();
            System.out.println(take);
            System.out.println(take1);
            System.out.println(take2);
            Object take3 = que.take();//程序等待死机，一直阻塞
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

1. 超时等待

```java
public static void test1(){
    ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue<>(3);
    boolean a = arrayBlockingQueue.offer("a");
    boolean b = arrayBlockingQueue.offer("b");
    boolean c = arrayBlockingQueue.offer("c");
    boolean d = false;//返回false
    try {
      //超时时间，超时单位
        d = arrayBlockingQueue.offer("d",2, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(a);
    System.out.println(d);
    System.out.println("---------");
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.remove());
    System.out.println(arrayBlockingQueue.remove());
    try {
        System.out.println(arrayBlockingQueue.poll(2,TimeUnit.SECONDS));//返回null
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

| 方式       | 抛出异常 | 不会抛出异常 | 阻塞等待 | 超时等待     |
| ---------- | -------- | ------------ | -------- | ------------ |
| 添加       | add      | offer        | put      | offer（...） |
| 移除       | remove   | poll         | take     | poll(..)     |
| 检测队列首 | element  | peek         |          |              |

#### 同步队列

​	测试同步队列,实现BlockingQueue接口
 * 和其他的BlockingQueue不一样，synchronousQueue不存储元素
 * put了一个元素，必须从里面先take取出来，否则不能再put
 * 结果：

put线程put1
put线程put2
take线程:1
put线程put3
take线程:2
take线程:3

输出与想象不一致

```java
package juc;

import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * 测试同步队列,实现BlockingQueue接口
 * 和其他的BlockingQueue不一样，synchronousQueue不存储元素
 * put了一个元素，必须从里面先take取出来，否则不能再put
 */
public class Test12 {
    public static void main(String[] args) {
        SynchronousQueue<String> queue = new SynchronousQueue<>();
        new Thread(()->{
            try {
                System.out.println(Thread.currentThread().getName()+"put1");
                queue.put("1");
                System.out.println(Thread.currentThread().getName()+"put2");
                queue.put("2");
                System.out.println(Thread.currentThread().getName()+"put3");
                queue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"put线程").start();
        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(3);
            System.out.println(Thread.currentThread().getName()+":"+queue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+":"+queue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName()+"："+queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },"take线程").start();
    }
}

```

### 线程池（重点）

三大方法、7大参数、4种拒绝策略

程序的运行：本质：占用系统的资源，优化资源的使用！池化技术

线程池，连接池，内存池，对象池

池化技术：事先准备一些资源，有人要用，就来这拿，用完之后归还

线程池好处：

1. 降低资源消耗
2. 提高响应速度
3. 方便管理

线程复用，控制最大并发数，管理线程

#### 线程池的使用

```java
package juc;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 使用线程池创建线程
 */
public class Test13 {
    public static void main(String[] args) {
//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定线程池大小
        ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的

        try {
            for (int i = 0; i < 10; i++) {
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //线程使用完毕，必须关闭线程
            threadPool.shutdown();
        }
    }
}
```

> 七大参数（看阿里巴巴编程规范）

#### 源码分析

单个线程

```java
public static ExecutorService newSingleThreadExecutor() {
    return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));
```

固定线程

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
}
```

可伸缩线程

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());
}
```

本质`ThreadPoolExecutor`

```java
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,//核心线程池大小 
                          int maximumPoolSize,//最大核心线程池大小 
                          long keepAliveTime, //超时时间
                          TimeUnit unit,//超时单位
                          BlockingQueue<Runnable> workQueue,//阻塞队列
                          ThreadFactory threadFactory, //线程工厂
                          RejectedExecutionHandler handler//拒绝策略
                         ) {
        this.ctl = new AtomicInteger(ctlOf(-536870912, 0));
        this.mainLock = new ReentrantLock();
        this.workers = new HashSet();
        this.termination = this.mainLock.newCondition();
        if (corePoolSize >= 0 && maximumPoolSize > 0 && maximumPoolSize >= corePoolSize && keepAliveTime >= 0L) {
            if (workQueue != null && threadFactory != null && handler != null) {
                this.corePoolSize = corePoolSize;
                this.maximumPoolSize = maximumPoolSize;
                this.workQueue = workQueue;
                this.keepAliveTime = unit.toNanos(keepAliveTime);
                this.threadFactory = threadFactory;
                this.handler = handler;
            } else {
                throw new NullPointerException();
            }
        } else {
            throw new IllegalArgumentException();
        }
    }
```

#### 手动创建线程池

四种拒绝策略

![image-20200523120423637](https://gitee.com/shaobing2021/typora/raw/master/img/20200728095816.png)

```
 private static final RejectedExecutionHandler defaultHandler = new ThreadPoolExecutor.AbortPolicy();//使用抛出异常的阻塞队列
```

```java
package juc;

import java.util.concurrent.*;

/**
 * 使用线程池创建线程
 */
public class Test13 {
    public static void main(String[] args) {
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 3, TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3), Executors.defaultThreadFactory(),
//                new ThreadPoolExecutor.AbortPolicy()  //默认拒绝策略，抛出异常
//                new ThreadPoolExecutor.CallerRunsPolicy()  //哪来的去哪里  ，main线程执行满负载
                new ThreadPoolExecutor.DiscardOldestPolicy()  //队列满了不会抛出异常，尝试和最早的线程竞争，竞争失败丢掉
//                new ThreadPoolExecutor.DiscardPolicy()  //队列满了不会抛出异常，丢出任务
        );

        try {
            //i<5  只有两个线程处理，  i<6 3 个线程处理  i<8 5个线程处理   i<9（5个线程，缓存3个） 则抛出异常
            for (int i = 0; i < 10; i++) {
                threadPool.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //线程使用完毕，必须关闭线程
            threadPool.shutdown();
        }
    }
}
```

##### CPU密集型和IO密集型

最大线程到底该如何定义

1.CPU密集型：几个核心就是几，逻辑处理器的数量，保持CPU效率最高

```
System.out.println(Runtime.getRuntime().availableProcessors());
```

2.IO密集型：>判断程序中最耗IO的线程

15个大型任务，io十分占用资源

### 四大函数接口

- lambda表达式

- 链式编程
- 函数式接口
- Stream流式计算

> 函数式接口：只有一个方法的接口

```java
@FunctionalInterface
public interface Runnable {
    void run();
}
//简化编程模型，在新版本框架底层大量应用
//foreach(消费者的函数式接口)
//消费者类的函数式接口
```

查看四大函数式接口

+ java.util.function

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T var1);
```

- java.util.predicate

```
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T var1);
```

+ java.util.consumer

```
@FunctionalInterface
public interface Consumer<T> {
    void accept(T var1);
```

+ java.util.supplier

```
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

#### 函数式接口

```java
package juc;

import java.util.function.Function;

public class Test14 {
    public static void main(String[] args) {
//        Function<String, String> function = new Function<>() {
//            @Override
//            public String apply(String s) {
//                return s;
//            }
//        };
        Function function = (str)->{
            return str;
        };
        Object hello = function.apply("hello");
        System.out.println(hello);
    }
}
```

#### 断定型接口

有一个输入参数，返回值只能是布尔值

```java
package juc;

import java.util.function.Function;
import java.util.function.Predicate;

public class Test14 {
    public static void main(String[] args) {
//        Predicate<String> predicate = new Predicate<>() {
//            @Override
//            public boolean test(String s) {
//                return s.isEmpty();
//            }
//        };
        Predicate<String> predicate = (str)->{
            return str.isEmpty();
        };
        boolean test = predicate.test("");
        System.out.println(test);

    }
}

```

> Consumer

#### 消费型接口

只有参数没有返回值

```java
package juc;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

public class Test14 {
    public static void main(String[] args) {
//        Consumer<String> c = new Consumer<String>() {
//            @Override
//            public void accept(String s) {
//                System.out.println(s);
//            }
//        };
        Consumer<String> c = (s)->{
            System.out.println(s);
        };
        c.accept("hello");
    }
}
```

#### 供给型接口

没有参数只有返回值

```java
public class Test14 {
    public static void main(String[] args) {
        Supplier<String> s = ()->{
            return "hello";
        };
        System.out.println(s.get());
    }
}
```

### Stream流式计算

> 存储+计算

集合、Mysql本质就是存储东西

计算都应该交给流操作

java.util.Stream

orpackage juc;


import Reflection.User;


import java.util.Arrays;

```java
import java.util.List;
public class Test15 {
​    public static void main(String[] args) {
​        User u1 = new User("a", 1, 21);
​        User u2 = new User("b", 2, 22);
​      	 User u3 = new User("c", 3, 23);
​        User u4 = new User("e", 4, 24);
​        User u5 = new User("f", 6, 25);
​        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);
​        list.stream()
​                .filter(u->{ return (u.getId()&1)==0; })//id余2为0
​                .filter(u->{ return u.getAge()>23; })//年龄大于23
​                .map(u->{ return u.getName().toUpperCase();})//名字转化大写
​                .sorted((uu1,uu2)->{ return uu2.compareTo(uu1);})//默认正序,实现compare接口之后逆序
​                .limit(1)
​                .forEach(System.out::println);
​    }
}
```



### ForkJoin

> 并行执行任务，提高效率，大数据量   相当于MapReduce

java.util.concurrent.ForkJoinPool

特点：工作窃取，维护的是一个双端队列，将别人的工作任务进行窃取

```
new ForkJoinPool().execute();

public void execute(ForkJoinTask<?> task) {
    this.externalSubmit(task);
}

public abstract class RecursiveTask<V> extends ForkJoinTask<V> {
```



```java
package juc;

import javax.swing.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;
import java.util.stream.LongStream;

/**
 * 求和计算任务
 * 1.继承Recuriseve接口
 * 2.拆分任务
 * 3.fork计算
 */
public class Test5 extends RecursiveTask<Long> {
    private Long start;
    private Long end;
    private Long temp = 10000L;
    public Test5(Long start,Long end){
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if ((end-start)<temp){
            Long sum = 0L;
            for (Long i = start; i < end; i++) {
                sum+=i;
            }
            return sum;
        }else {//递归
            long mid = (start+end)/2;
            Test5 task1 = new Test5(start, mid);
            task1.fork();
            Test5 task2 = new Test5(mid+1, end);
            task2.fork();
            return task1.join()+task2.join();
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();
        test();//7021
//        test1();//4555
        long end = System.currentTimeMillis();
        System.out.println(end-start);
    }
    public static void test() throws ExecutionException, InterruptedException {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Test5 task = new Test5(0L, 10_0000_0000L);
        ForkJoinTask<Long> submit = forkJoinPool.submit(task);
        Long result = submit.get();
        System.out.println(result);
    }
    public static void test1(){
        long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum);
        System.out.println(sum);
    }
}
```

### 异步回调

ajax：服务端和客户端异步通信

核心在于：可以获得结果相当于两个线程跑，主线程获取另一个的结果

#### 没返回值的异步通信

```java
package juc1;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;


/**
 * 异步调用：CompletableFuture
 * 异步执行
 * 成功回调
 * 失败回调
 */
public class Test1 {
    public static void main(String[] args) {
        CompletableFuture<Void> future = CompletableFuture.runAsync(()->{
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"runAsync=>void");
        });
        System.out.println("hello");
        try {
            future.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

#### 有返回值的异步通信

```java
package juc1;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;


/**
 * 异步调用：CompletableFuture
 * 异步执行
 * 成功回调
 * 失败回调
 */
public class Test1 {
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread().getName()+"future");
            int i= 10/0;//可以尝试不加，则正常回调
            return 1024;
        });
        try {
            Integer res = future.whenComplete((t, u) -> {
                System.out.println("t:" + t + "u:" + u);//t是正常的返回结果   //u为错误信息
            }).exceptionally((e) -> {
                System.out.println(e.getMessage());
                return 500;
            }).get();    //如果报错，错误信息为500
            System.out.println(res);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }
}
```

### JMM

> volatile是Java虚拟机提供轻量级的同步机制

1. 保证可见性
2. 不保证原子性
3. 禁止指令重排

**关于JMM的同步约定**

1. 线程解锁前，将共享变量立刻刷回主存
2. 线程加锁前，必须读取主存中最新值到工作内存中
3. 加锁和解锁是同一把锁

#### 引出volatile

```java
package juc1;

import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 该例子充分说明上诉模型问题
 */
public class Test2 {
    private static int num = 0;
    public static void main(String[] args) {
        new Thread(()->{
            while (num == 0){
                
            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        num =1 ;
        System.out.println(num);
    }
}
```

### Volatile

- #### 加volatile保证可见性

```java
package juc1;

import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 加volatile保证可见性
 */
public class Test2 {
    private volatile static int num = 0;
    public static void main(String[] args) {
        new Thread(()->{
            while (num == 0){

            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        num =1 ;
        System.out.println(num);
    }
}
```

- #### 不保证原子性

原子性：不可分割

线程A在执行任务的时候，不能被打扰，也不能被分割,要么同时成功，要么同时失败

```java
package juc1;
/**
 * 验证不保证原子性
 */
public class Test3 {
    private volatile static int num = 0;//volatile不保证原子性
    public  static void add(){//加synchronized sum为20000
        num++;
    }

    public static void main(String[] args) {
        //理论上值为20000
        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }
        while (Thread.activeCount()>2){//要其他线程完成，即只要除main，gc线程还有线程存活，就等待
            Thread.yield();
        }
        System.out.println(num);
    }
}
```

> 解决原子性问题

java.util.concurrent.atomic

```java
package juc1;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * 验证不保证原子性
 */
public class Test3 {
    //原子类的Integer
    private  static AtomicInteger num = new AtomicInteger();//volatile不保证原子性
    public  static void add(){//加synchronized sum为20000
        num.getAndIncrement();//AtomicInteger+1
    }

    public static void main(String[] args) {
        //理论上值为20000
        for (int i = 0; i < 20; i++) {
            new Thread(()->{
                for (int j = 0; j < 1000; j++) {
                    add();
                }
            }).start();
        }
        while (Thread.activeCount()>2){//要其他线程完成，即只要除main，gc线程还有线程存活，就等待
            Thread.yield();
        }
        System.out.println(num);
    }
}
//输出结果不会是两万
```

#### 指令重排

什么是指令重排：计算机不按照你写的那样去执行

源代码-->编译器优化的重排-->指令并行可能导致重排--->内存系统重排--->执行

处理器在进行指令重排的时候，考虑：数据之间的依赖性

```java
int x = 1;
int x = 4;
x= x+8;
y=x*x;//可能执行顺序为1234 2134
//可不肯恶搞4123
```

默认：a,b,x,y为0

线程A:x=a,b=1   重排b=1,x=a   x =2

线程B:y=b,a=2  重排a=2,y=b     y=1

两条线程分开执行则x，y赋值为0

但是由于指令重排，会导致发生变化

只要加了volatile可能避免指令重排

内存屏障：禁止写入时候普通写和volatile谢谢指令顺序交换

1. 保证特定操作执行顺序
2. 保证某些变量的内存可见性

### 单例模式

详见涉及模式

### CAS

```java
atomicInteger.getAndIncrement()

 public final int getAndIncrement() {
        return U.getAndAddInt(this, VALUE, 1);
    }
    //即那个U    Java无法操作内存，调用C++操作内存
    public class AtomicInteger extends Number implements Serializable {
    private static final long serialVersionUID = 6214790243416807050L;
    private static final Unsafe U = Unsafe.getUnsafe();
    private static final long VALUE;
    private volatile int value;
```

深入理解getAndAddInt，自旋锁

```java
@HotSpotIntrinsicCandidate
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = this.getIntVolatile(o, offset);//获得内存地址的值
    } while(!this.weakCompareAndSetInt(o, offset, v, v + delta));

    return v;
}
```

CAS:比较当前工作内存中的值和主内存的值，如果值是期望的，则执行操作，否则一直循环

缺点：

1. 循环会耗时
2. 一次性只能保证一个共享变量的原子性
3. ABA问题

#### ABA问题

> 解决ABA问题，引入原子操作！对应的思想：乐观锁

```java
package cas;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * 乐观锁
 */
public class CASDemo {
    //CAS:比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);
        //如果我期望的值达到了，那么就更新，否则，不更新.CAS是CPU并发原语
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(2020,6666));
        System.out.println(atomicInteger.get());
    }
}
```

> 此处注意所有相同类型的包装类对象之间值的比较，全部使用equals方法比较
>
> 正常业务是对象，不会出现问题AtomicStampedReference<User> 

```java
package cas;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicStampedReference;

/**
 * 乐观锁
 * A线程修改，同时会修改版本
 * B线程进行修改，同时赋与初始值，就会发现版本不一致，修改失败
 * 结果发现ACAS操作为true，B为false
 */
public class CASDemo {
    //CAS:比较并交换
    public static void main(String[] args) {

        //注意如果泛型是包装类，注意对象引用问题
//        AtomicInteger atomicInteger = new AtomicInteger(2020);
        AtomicStampedReference<Integer> atomicInteger = new AtomicStampedReference<>(1, 1);
        new Thread(()->{
            int stamp = atomicInteger.getStamp();//获得版本号
            System.out.println("a1:"+stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("a:"+atomicInteger.compareAndSet(1, 2,
                    atomicInteger.getStamp(), atomicInteger.getStamp() + 1));
            System.out.println("a2:"+atomicInteger.getStamp());
            System.out.println("a:"+atomicInteger.compareAndSet(2, 1,
                    atomicInteger.getStamp(), atomicInteger.getStamp() + 1));
            System.out.println("a3:"+atomicInteger.getStamp());
        },"A").start();
        //和乐观锁原理相同
        new Thread(()->{
            int stamp = atomicInteger.getStamp();
            System.out.println("b1:"+stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(atomicInteger.compareAndSet(1, 10, stamp, stamp + 1));
            System.out.println("b2:"+atomicInteger.getStamp());
        },"b").start();
    }
}
```

### 各种锁

#### 公平锁非公平锁

> 公平，不能插队    必须先来后到
>
> 非公平，可以插队     有些任务耗时间长，当然放在后面干号，所以默认非公平锁

```java
//默认非公平锁
public ReentrantLock() {
    this.sync = new ReentrantLock.NonfairSync();
}
//修改成公平锁
 public ReentrantLock(boolean fair) {
        this.sync = (ReentrantLock.Sync)(fair ? new ReentrantLock.FairSync() : new ReentrantLock.NonfairSync());
    }
```

#### 可重入锁

> 又叫递归锁，拿到了外面的锁就可以拿到里面的锁

在java 中，synchronized和java.util.concurrent.locks.ReentrantLock是可重入锁。
问：当一个线程获得当前实例的锁lock，并且进入了方法A，该线程在方法A没有释放该锁的时候，是否可以再次进入使用该锁的方法B？
答：不可重入锁：在方法A释放锁之前，不可以再次进入方法B 可重入锁：在方法A释放该锁之前可以再次进入方法B

asms
acall
bsms
bcall

输出结果永远都是A或者B运行完，再换线程运行

```java
package cas;

public class Demo1 {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(()->{
            phone.sms();
        },"a").start();
        new Thread(()->{
            phone.sms();
        },"b").start();
    }
}

class Phone{
    public synchronized void sms(){
        System.out.println(Thread.currentThread().getName()+"sms");
        call();
    }
    public synchronized void call(){
        System.out.println(Thread.currentThread().getName()+"call");
    }
}
```

注意锁必须配对

#### 自旋锁

不断尝试直到成功位置，do   while

```java
AtomicInteger atomicInteger = new AtomicInteger();
atomicInteger.getAndIncrement()
```

```java
@HotSpotIntrinsicCandidate
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = this.getIntVolatile(o, offset);
    } while(!this.weakCompareAndSetInt(o, offset, v, v + delta));

    return v;
}
```

只有a能获得锁，同时a先解锁，b才能解锁

a-->mylock
b-->mylock
a-->my unlock
b-->my unlock

```java
package cas;

import com.sun.security.jgss.GSSUtil;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class SpinlockDemo {
    AtomicReference<Thread> atomicReference = new AtomicReference<>();
    //加锁
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"-->mylock");
        while (!atomicReference.compareAndSet(null,thread)){

        }
    }
    //解锁
    public void myUnlock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"-->my unlock");
        atomicReference.compareAndSet(thread,null);
    }

    public static void main(String[] args) throws InterruptedException {
        SpinlockDemo lock = new SpinlockDemo();
        new Thread(()->{
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(2);
            }catch (Exception e){

            }finally {
                lock.myUnlock();
            }
        },"a").start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(()->{
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            }catch (Exception e){

            }finally {
                lock.myUnlock();
            }
        },"b").start();
    }
}
```

#### 死锁

```java
package cas;

import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 死锁测试
 */
public class DeadLock {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new MyThread(lockA,lockB),"t1").start();
        new Thread(new MyThread(lockB,lockA),"t2").start();
    }
}
class MyThread implements Runnable{
    private String lockA;
    private String lockB;

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+"lock:"+lockA+"-->get"+lockB);
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+"lock:"+lockB+"-->get"+lockA);
            }
        }
    }
}
```
##### 排查死锁问题

1.使用jps -l定位进程号

2.使用jstack 进程号