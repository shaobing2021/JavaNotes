## 索引简介

> 索引是帮助MySQL高效获取数据的数据结构

提高数据查询的效率。

索引：排好序的快速查找数据结构！索引会影响where后面的查找，和order by 后面的排序。

## 索引优劣势

### 优势

* 类似于书籍的目录索引，提高数据检索的效率
* 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗

#### 劣势

* 索引也是一张表，该表中保存了主键和索引字段，并指向实体类的记录，因此索引列也是要占用空间
* 虽然索引提高查询效率，同时也降低更新表的速度，如对表的Insert，update，delete。更新表时，不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

## 索引的分类

1. 从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。

2. 从应用层次来分：普通（单列）索引，唯一索引（必须唯一，可以空值），复合索引（一个索引包含多个列）。

3. 根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。

### 说明

> 应用层次上划分

- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引
- 唯一索引：索引列的值必须唯一，但允许有空值
- 复合索引：即一个索引包含多个列。在表中的多个字段组合上创建的索引；组合索引的使用，需要遵循最左前缀原则；一般情况下，建议使用组合索引代替单列索引；

> 物理顺序划分

- 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。
  - 主键索引：Innodb必须有主键，没有显示指定，Mysql会自动选择一个隐含字段作为主键
  - 辅助索引：Innodb赋值索引的data域存储主键值而不是地址，因为查询可能需要搜索两次索引树
  
- 非聚簇索引：数据和索引不在一起，Myisam

- 覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，查询列被所见索引覆盖，从而避免回表


## 索引的底层实现

mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。

## 问题

**问：为什么索引结构默认使用B-Tree，而不是hash，二叉树，红黑树？**

**hash：**虽然可以快速定位，但是没有顺序，IO复杂度高	，无法支持范围查询。二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

**红黑树**：树的高度随着数据量增加而增加，IO代价高。

**为什么官方建议使用自增长主键作为索引**

结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。

总之就是减少分裂和移动的频率。

## b树与b+树

### B树

本质是多路二叉树；叶节点具有相同的深度，叶节点的指针为空；所有索引元素不重复；节点中数据索引从左到右依次递增的；如果某个节点key达到m则进行分裂，向上分裂

> B树又叫多路平衡搜索树，一颗m叉的B树特性如下

* 树种每个节点最多包含m个孩子
* 每个非叶子节点由n个key与n+1个指针组成，其中m/2向上取整-1 <= n <= m-1，即最多m个指针，最多m-1个key（元素）
* 除根节点和叶子节点外，每个节点最少由ceil(m/2)个孩子
* 若根节点不是叶子节点，则至少有两个孩子
* 所有的叶子节点都在同一层

![B树索引示意图](https://pic4.zhimg.com/80/v2-1405edb8b0b8d43150b50e7d1995fcf1_720w.jpg)



B树相比于二叉树而言，查询数据效率更高，因为对于相同数据量而言，B树层级更小，因此搜索速度更快

### [B+树（B树的变种）](https://www.jianshu.com/p/71700a464e97)

* m叉b+树每个节点最多有m个key，而B树最多m-1个key（这是因为所有b+树非叶子节点不存数据）
* b+树的叶子节点保存所有的key信息，其key大小顺序排列
* 所有的非叶子节点都可以看成key索引的一部分

* 非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低 ；从而可以减少IO，此外B+树性能更稳定，因为B树可能最好情况根节点，最坏情况叶子节点，而B+树都需要查找到叶子节点
* 叶子节点包含所有索引字段；叶子节点比b树增加了指针的双向连接；(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；（有利于order by）

![B+树索引示意图](https://pic3.zhimg.com/80/v2-c9132812a8980b1c8fefd2cff120b263_720w.jpg)

### MySQL的索引要使用B+树而不是其它树形结构?比如B树？

这个问题的复杂版本可以参考本文；

**简单回答是：**

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）

指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；‘

> 个人见解：如果使用b树，b树非叶子节点也会存储数据，那么耗费空间变多，而mysql节点存储容量是16k，导致能存储的指针数量变少。这种情况下要保存大量数据，只能增加树的高度，导致IO操作变多。
>
> 同时B树最好情况是查找根节点，但是最坏进行多次IO，B+树范围查询更加方便

## mysql支持存储数据容量

MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)那么一颗高度为2的B+树能存储的数据为：1170*16=18720条，一颗高度为3的B+树能存储的数据为：1170*1170*16=21902400（千万级条）

```text
show global status like `Innodb_page_size`
```

因此，B+树存储大数据量的表也可以非常高效的获取数据，MySQL使用B+树作为索引的数据结构。

## 为什么非主键索引结构叶子节点存储的是主键值？

- 主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；
- 如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。

## 索引操作

* 显示所有索引信息

`SHOW INDEX FROM 表名；`

* 增加一个全文索

`CREATE [unique|fulltext|spatial] index 索引名 [using index_type  索引类型例如B树] on 表名（列名）`

`alter table 表名 add [fulltext|index|unique|primary ] index  索引名（列名）`

* 删除索引

`drop index [index_name] on 表名`

```
#显示索引
mysql> show index from account\G;
        Table: account
   Non_unique: 0
     Key_name: PRIMARY    //主键会自动添加索引
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 6
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE    //默认都是B树
      Comment:
```

## 索引优化原则

#### 1. 选择唯一性索引

唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

#### 2. 为经常需要排序、分组和联合操作的字段建立索引

经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

#### 3. 为常作为查询条件的字段建立索引

如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。

注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。

#### 4. 限制索引的数目

索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。

如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。

#### 5. 尽量使用数据量少的索引

如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。

#### 6. 数据量小的表最好不要使用索引

由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

#### 7. 尽量使用前缀来索引

如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

#### 8. 删除不再使用或者很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

#### 9.利用最左前缀，N个列组合

```
创建复合索引：
create index index_name_eamil_status on tb_name(name,email,status);
相当于
 对name
 对name，eamil
 对name，eamil，status创建了索引
```

